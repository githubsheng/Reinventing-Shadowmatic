/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/menu.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: randomizeRotation, setupMysteriousObjectBuffer, updateUniformsf, resumePlaying, stopPlaying */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomizeRotation\", function() { return randomizeRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupMysteriousObjectBuffer\", function() { return setupMysteriousObjectBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateUniformsf\", function() { return updateUniformsf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resumePlaying\", function() { return resumePlaying; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stopPlaying\", function() { return stopPlaying; });\n/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ \"./src/time.js\");\n/* harmony import */ var _obj__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./obj */ \"./src/obj.js\");\n//context\n\n\n\nvar canvas = document.querySelector(\"#canvas\", {stencil: true});\n\nvar gl = WebGLDebugUtils.makeDebugContext(canvas.getContext(\"webgl\"));\nvar viewportWidth = canvas.width;\nvar viewportHeight = canvas.height;\nvar shadowViewPortWidth = 1024;\nvar shadowViewPortHeight = 1024;\n\n//-------------------------------------------------------------------------------------------------------------\n//  matrices used by normal rendering\n//-------------------------------------------------------------------------------------------------------------\n//static\nvar projectionMatrix = mat4.create();\nvar viewMatrix = mat4.create();\nvar VPMatrix = mat4.create();\n\n// main camera\nvar eyeCoord = vec3.fromValues(-45.086, -10.548, 131.721);\nvar eyeLookAtCoord = vec3.fromValues(-29.134, -6.732, -24.9);\nvar eyeUpDir = vec3.fromValues(0, 1, 0);\nmat4.perspective(projectionMatrix, 0.5556, viewportWidth / viewportHeight, 41.145, 394.625);\n// eye coordinate is also coded in shader to calculate specular, update this values in both places if needed.\nmat4.lookAt(viewMatrix, eyeCoord, eyeLookAtCoord, eyeUpDir);\nmat4.multiply(VPMatrix, projectionMatrix, viewMatrix);\n\nvar objBaseColor_ambient = vec3.fromValues(0.7, 0.7, 0.7);\nvar objBaseColor_diffuse = vec3.fromValues(0.7, 0.7, 0.7);\nvar objBaseColor_specular = vec3.fromValues(0.9, 0.9, 0.9);\nvar warmLightDir = vec3.fromValues(-83.064, -1.99, -173.467);\nvec3.normalize(warmLightDir, warmLightDir);\nvar warmLightColor = vec3.fromValues(1.0, 1.0, 0.6);\nvar coldLightDir = vec3.fromValues(0.0, 1.0, 0.0);\nvec3.normalize(coldLightDir, coldLightDir);\nvar coldLightColor = vec3.fromValues(0.196, 0.361, 0.608);\nvar ambientLightColor = vec3.fromValues(0.3, 0.3, 0.3);\n\n//change in each frame\nvar m_modelMatrix = mat4.create();\n\nfunction randomizeRotation(){\n    mat4.identity(m_modelMatrix);\n    mat4.rotateX(m_modelMatrix, m_modelMatrix, 1.0);\n    mat4.rotateY(m_modelMatrix, m_modelMatrix, 1.0);\n    mat4.rotateZ(m_modelMatrix, m_modelMatrix, 1.0);\n}\n\nvar w_modelMatrix = mat4.create();\nvar wallMVPMatrix = mat4.create();\nmat4.multiply(wallMVPMatrix, VPMatrix, w_modelMatrix);\n\nvar MVPMatrix = mat4.create();\nvar normalMatrix = mat3.create();\n\n//-------------------------------------------------------------------------------------------------------------\n//  matrices used by shadow rendering\n//-------------------------------------------------------------------------------------------------------------\nvar shadowProjectionMatrix = mat4.create();\nvar shadowViewMatrix = mat4.create();\nvar shadowVPMatrix = mat4.create();\n\nvar wallShadowMVPMatrix = mat4.create();\nvar texUnit = 1.0 / shadowViewPortWidth; //assuming shadow map width and height are the same\nvar pcfOffsets = new Float32Array([-1.5 * texUnit, -0.5 * texUnit, 0.5 * texUnit, 1.5 * texUnit]);\n\n// 用来投射阴影的暖光\n// 83.064 / 1.99 / 173.467 -> 0 0 0\n// 用来绘制投影的镜头的位置也是同上\n// fov 18.3833\n// near clip 152.723\n// far clip 351.216\n\n//static\nvar shadowEyeCoord = vec3.fromValues(83.064, 1.99, 173.467);\nvar shadowEyeLookAt = vec3.fromValues(0, 0, 0);\nvar shadowEyeUpDir = vec3.fromValues(0, 1, 0);\nmat4.perspective(shadowProjectionMatrix, 0.3287, shadowViewPortWidth / shadowViewPortHeight, 152.723, 351.216);\n//this is the same as diffuse light source direction.\nmat4.lookAt(shadowViewMatrix, shadowEyeCoord, shadowEyeLookAt, shadowEyeUpDir);\nmat4.multiply(shadowVPMatrix, shadowProjectionMatrix, shadowViewMatrix);\nmat4.multiply(wallShadowMVPMatrix, shadowVPMatrix, w_modelMatrix);\n//change in every frame\nvar shadowMVPMatrix = mat4.create();\n\nfunction createProgram(vertexShaderId, fragmentShaderId, vertexShaderSrc, fragmentShaderSrc) {\n    var program = gl.createProgram();\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    var vertexShaderSource = vertexShaderSrc || document.querySelector(vertexShaderId).text;\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.compileShader(vertexShader);\n\n    var vertexShaderCompiled = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);\n    if (!vertexShaderCompiled) {\n        console.log(\"Failed to compile vertex shader: \" + vertexShaderId);\n        var compilationLog = gl.getShaderInfoLog(vertexShader);\n        console.log('Shader compiler log: ' + compilationLog);\n    }\n\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    var fragmentShaderSource = fragmentShaderSrc || document.querySelector(fragmentShaderId).text;\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    gl.compileShader(fragmentShader);\n\n    var backgroundFragmentShaderCompiled = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);\n    if (!backgroundFragmentShaderCompiled) {\n        console.log(\"Failed to compile fragment shader: \" + fragmentShaderId);\n        var compilationLog = gl.getShaderInfoLog(fragmentShader);\n        console.log('Shader compiler log: ' + compilationLog);\n    }\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    gl.validateProgram(program);\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n        console.log(\"program validation failed: \" + vertexShaderId + \" \" + fragmentShaderId);\n    }\n    return program;\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  set up program to render the mysterious object.\n//-------------------------------------------------------------------------------------------------------------\n//create normal program\nvar normalProgram;\nvar n_aVertexPosition, n_aNormal, n_uObjMPV, n_uObjM, n_uNormalM;\nvar n_baseColorAmbient, n_baseColorDiffuse, n_baseColorSpecular,\n    n_warmLightDir, n_warmLightColor, n_coldLightDir, n_coldLightColor, n_ambientLightColor;\nvar n_shininess, n_eyeCd;\nvar n_uShadowMVP, n_uShadowMap, n_pcfOffsets;\n\nfunction createNormalProgram(vertexShaderSrc, fragmentShaderSrc){\n    normalProgram = createProgram(\"#shader-vertex\", \"#shader-fragment\", vertexShaderSrc, fragmentShaderSrc);\n    //get attribute locations of normal program\n    //vertice positions and normal positions\n    n_aVertexPosition = gl.getAttribLocation(normalProgram, \"aVertexPosition\");\n    n_aNormal = gl.getAttribLocation(normalProgram, \"aNormal\");\n    //MVP matrix and normal matrix\n    n_uObjMPV = gl.getUniformLocation(normalProgram, \"uObjMVP\");\n    n_uObjM = gl.getUniformLocation(normalProgram, \"uObjM\");\n    n_uNormalM = gl.getUniformLocation(normalProgram, \"uNormalM\");\n    //colors & lights\n    n_baseColorAmbient = gl.getUniformLocation(normalProgram, \"mysObjBaseColor.ambient\");\n    n_baseColorDiffuse = gl.getUniformLocation(normalProgram, \"mysObjBaseColor.diffuse\");\n    n_baseColorSpecular = gl.getUniformLocation(normalProgram, \"mysObjBaseColor.specular\");\n    n_warmLightDir = gl.getUniformLocation(normalProgram, \"warmLight.direction\");\n    n_warmLightColor = gl.getUniformLocation(normalProgram, \"warmLight.color\");\n    n_coldLightDir = gl.getUniformLocation(normalProgram, \"coldLight.direction\");\n    n_coldLightColor = gl.getUniformLocation(normalProgram, \"coldLight.color\");\n    n_ambientLightColor = gl.getUniformLocation(normalProgram, \"ambientLightColor\");\n    n_eyeCd = gl.getUniformLocation(normalProgram, \"eyeCd\");\n    n_shininess = gl.getUniformLocation(normalProgram, \"shininess\");\n\n    //shadow MVP matrix and shadow map\n    n_uShadowMVP = gl.getUniformLocation(normalProgram, \"uShadowMVP\");\n    n_uShadowMap = gl.getUniformLocation(normalProgram, \"uShadowMap\");\n    n_pcfOffsets = gl.getUniformLocation(normalProgram, \"pcfOffsets\");\n}\n\n//var sp_aVertexPosition = gl.getAttribLocation(specularProgram, \"aVertexPosition\");\n//var sp_aNormal = gl.getAttribLocation(specularProgram, \"aNormal\");\n\n//-------------------------------------------------------------------------------------------------------------\n//  set up program to draw shadow maps that store information about shadows casted by the mysterious object\n//-------------------------------------------------------------------------------------------------------------\n//create shadow program\nvar shadowProgram;\nvar s_aVertexPosition, s_uObjMVP;\n\nfunction createShadowProgram(vertexShaderSrc, fragmentShaderSrc){\n    shadowProgram = createProgram(\"#shadow-shader-vertex\", \"#shadow-shader-fragment\", vertexShaderSrc, fragmentShaderSrc);\n    //get attribute location of shadow program\n    s_aVertexPosition = gl.getAttribLocation(shadowProgram, \"aVertexPosition\");\n    s_uObjMVP = gl.getUniformLocation(shadowProgram, \"uObjMVP\");\n}\n\n//-------------------------------------------------------------------------------------------------------------\n// set up program to render the wall\n//-------------------------------------------------------------------------------------------------------------\nvar wallProgram;\nvar w_aVertexPosition, w_uObjMVP, w_uShadowMVP, w_uShadowMap, w_pcfOffsets;\n\nfunction createWallProgram(vertexShaderSrc, fragmentShaderSrc){\n    wallProgram = createProgram(\"#wall-shader-vertex\", \"#wall-shader-fragment\", vertexShaderSrc, fragmentShaderSrc);\n    w_aVertexPosition = gl.getAttribLocation(wallProgram, \"aVertexPosition\");\n    w_uObjMVP = gl.getUniformLocation(wallProgram, \"uObjMVP\");\n    w_uShadowMVP = gl.getUniformLocation(wallProgram, \"uShadowMVP\");\n    w_uShadowMap = gl.getUniformLocation(wallProgram, \"uShadowMap\");\n    w_pcfOffsets = gl.getUniformLocation(wallProgram, \"pcfOffsets\");\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  set up program to draw the background\n//-------------------------------------------------------------------------------------------------------------\nvar backgroundProgram;\nvar b_aVertexPosition, b_vTextureCoordinate, b_uBgTexture1, b_uBgTexture2, b_radio;\n\nfunction createBackgroundProgram(vertexShaderSrc, fragmentShaderSrc){\n    backgroundProgram = createProgram(\"#background-shader-vertex\", \"#background-shader-fragment\", vertexShaderSrc, fragmentShaderSrc);\n    b_aVertexPosition = gl.getAttribLocation(backgroundProgram, \"aVertexPosition\");\n    b_vTextureCoordinate = gl.getAttribLocation(backgroundProgram, \"aTexCd\");\n    b_uBgTexture1 = gl.getUniformLocation(backgroundProgram, \"uBackgroundTextureOne\");\n    b_uBgTexture2 = gl.getUniformLocation(backgroundProgram, \"uBackgroundTextureTwo\");\n    b_radio = gl.getUniformLocation(backgroundProgram, \"radio\");\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  model data set up\n//-------------------------------------------------------------------------------------------------------------\n//introduce the vertices, normals and indices of the model, in this case its a cube.\nvar m_vertexBuffer = gl.createBuffer();\nvar m_normalsBuffer = gl.createBuffer();\nvar m_elementBuffer = gl.createBuffer();\n\nvar w_vertexBuffer = gl.createBuffer();\nvar w_normalBuffer = gl.createBuffer();\nvar w_elementBuffer = gl.createBuffer();\n\nvar m_indices_number;\nvar w_indices_number;\n\nvar b_vtBuffer = gl.createBuffer();\nvar g_quadBuffer = gl.createBuffer();\n\nvar b_vtSize;\nvar b_vertices_number;\n\nvar g_quadSize;\nvar g_quad_vertices_number;\n\nvar scale = 2.5;\nfunction setupMysteriousObjectBuffer(dataStr){\n    var loader = new _obj__WEBPACK_IMPORTED_MODULE_1__[\"OBJDoc\"]();\n    loader.parse(dataStr, scale); //scale should be 2.5\n    var data = loader.getDrawingInfo();\n\n    //mysterious object related\n    //Float32 corresponds to gl.FLOAT\n    var mysteriousObjectVertices = data[\"MysteriousObject\"].vertices;\n\n    //Float32 corresponds to gl.FLOAT\n    var mysteriousObjectNormals = data[\"MysteriousObject\"].normals;\n\n    //Uint16Array correspond to gl.UNSIGNED_SHORT\n    var mysteriousObjectIndices = data[\"MysteriousObject\"].indices;\n\n    //var mysteriousObjectVertices = new Float32Array([\n    //    10.0, 10.0, 10.0, -10.0, 10.0, 10.0, -10.0, -10.0, 10.0, 10.0, -10.0, 10.0,\n    //    10.0, 10.0, 10.0, 10.0, -10.0, 10.0, 10.0, -10.0, -10.0, 10.0, 10.0, -10.0,\n    //    10.0, 10.0, 10.0, 10.0, 10.0, -10.0, -10.0, 10.0, -10.0, -10.0, 10.0, 10.0,\n    //    -10.0, 10.0, 10.0, -10.0, 10.0, -10.0, -10.0, -10.0, -10.0, -10.0, -10.0, 10.0,\n    //    -10.0, -10.0, -10.0, 10.0, -10.0, -10.0, 10.0, -10.0, 10.0, -10.0, -10.0, 10.0,\n    //    10.0, -10.0, -10.0, -10.0, -10.0, -10.0, -10.0, 10.0, -10.0, 10.0, 10.0, -10.0]);\n    //\n    //var mysteriousObjectNormals = new Float32Array([\n    //    0.0, 0.0, 10.0, 0.0, 0.0, 10.0, 0.0, 0.0, 10.0, 0.0, 0.0, 10.0,\n    //    10.0, 0.0, 0.0, 10.0, 0.0, 0.0, 10.0, 0.0, 0.0, 10.0, 0.0, 0.0,\n    //    0.0, 10.0, 0.0, 0.0, 10.0, 0.0, 0.0, 10.0, 0.0, 0.0, 10.0, 0.0,\n    //    -10.0, 0.0, 0.0, -10.0, 0.0, 0.0, -10.0, 0.0, 0.0, -10.0, 0.0, 0.0,\n    //    0.0, -10.0, 0.0, 0.0, -10.0, 0.0, 0.0, -10.0, 0.0, 0.0, -10.0, 0.0,\n    //    0.0, 0.0, -10.0, 0.0, 0.0, -10.0, 0.0, 0.0, -10.0, 0.0, 0.0, -10.0]);\n    //\n    //var mysteriousObjectIndices = new Uint16Array([\n    //    0, 1, 2, 0, 2, 3,\n    //    4, 5, 6, 4, 6, 7,\n    //    8, 9, 10, 8, 10, 11,\n    //    12, 13, 14, 12, 14, 15,\n    //    16, 17, 18, 16, 18, 19,\n    //    20, 21, 22, 20, 22, 23]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, mysteriousObjectVertices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_normalsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, mysteriousObjectNormals, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m_elementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mysteriousObjectIndices, gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n    m_indices_number = mysteriousObjectIndices.length;\n\n    //reset all binding to clean up.\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n\nfunction setupSceneBuffers(dataStr){\n    var loader = new _obj__WEBPACK_IMPORTED_MODULE_1__[\"OBJDoc\"]();\n    loader.parse(dataStr, scale); //scale should be 2.5\n    var data = loader.getDrawingInfo();\n\n    //wall related\n    var wallVertices = data[\"Wall\"].vertices;\n    var wallNormals = data[\"Wall\"].normals;\n    var wallIndices = data[\"Wall\"].indices;\n\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, w_vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, wallVertices, gl.STATIC_DRAW);\n\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, w_normalBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, wallNormals, gl.STATIC_DRAW);\n\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, w_elementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, wallIndices, gl.STATIC_DRAW);\n\n    w_indices_number = wallIndices.length;\n\n    //rectangular as background\n    var verticesTexCoords = new Float32Array([\n        //for each line, the two on the left are vertices coordinates,\n        //and the two on the right are textures coordinates\n        -1.0,  1.0, 0.0, 1.0,\n        -1.0, -1.0, 0.0, 0.0,\n        1.0,  1.0, 1.0, 1.0,\n        1.0, -1.0, 1.0, 0.0\n    ]);\n\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, b_vtBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, verticesTexCoords, gl.STATIC_DRAW);\n    b_vtSize = verticesTexCoords.BYTES_PER_ELEMENT;\n    b_vertices_number = 4;\n\n    //general quad\n    var generalQuadCoords = new Float32Array([-1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0]);//use strap\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, g_quadBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, generalQuadCoords, gl.STATIC_DRAW);\n    g_quadSize = generalQuadCoords.BYTES_PER_ELEMENT;\n    g_quad_vertices_number = 4;\n\n    //reset all binding to clean up.\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  shadow frame buffer\n//-------------------------------------------------------------------------------------------------------------\n/*\n by default, the webgl system draws using a color buffer and, when using the hidden surface removal function, a depth buffer.\n The final image is kept in the color buffer. The frame buffer object is an alternative mechanism that I can use instead of a color\n buffer or a depth buffer. Unlike a color buffer, the content drawn in a frame buffer object is not directly displayed on the <canvas>.\n And I get a chance to perform various processing.\n */\n//create frame buffer.\nvar shadowFrameBuffer;\nfunction setupShadowMapFrameBuffer(){\n    shadowFrameBuffer = gl.createFramebuffer();\n    //bind\n    gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFrameBuffer);\n\n    //set up the texture of this frame buffer, its used as a replacement of default color buffer.\n    var texture = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    /*\n     the 1st parameter: indicates we are configuring gl.TEXTURE_2D, which now points to our texture.\n\n     the 2nd parameter: says the mipmap level, since we are not useing mipmapping for this texture we will make it 0, which\n     means base level.\n\n     the 3rd parameter: the internal format of the image, we will use rgba here, as it works with our pack and unpack function\n     in the shader.\n\n     the 4th parameter & 5 th parameters: the width and height of the texture.\n\n     the 5th parameter: border width, 0. not sure what this is for.\n\n     the 6th parameter: in webgl this must be the same as 3rd parameter, the internal format of the texture.\n\n     the 7th parameter: the data type of a texel, these types are used to compress image. I use unsigned byte here (the largest type),\n     because image compression and size is not a concern in here, and this seems to work with the pack and unpack function in the shader.\n\n     the 8th parameter: the image data. in this case its null, because i am not loading an external image into this texture.\n     */\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, shadowViewPortWidth, shadowViewPortHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    //specify how we do min / max filtering.\n    //the default value for gl.TEXTURE_MIN_FILTER is gl.NEAREST_MIPMAP_LINEAR. Since I am not using mipmap here i will just change it to gl.NEAREST\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    /*\n     a render is a texture with a hint - that you won't expect some functionality from them. You only use it when you will never use it\n     as a texture. Because the graphic card knows you won't use some certain functionalities, it can do some optimizations. However,\n     there is no much difference nowdays. This render buffer is used as a replacement of the default render buffer.\n     */\n    var depthBuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\n    //second parameter says that this render buffer is used as a depth buffer, and the buffer storage will be configured accordingly.\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, shadowViewPortWidth, shadowViewPortHeight);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\n    /*\n     finally i will bind this texture to my shadow frame buffer.\n\n     gl.COLOR_ATTACHMENT0 says I will bind the texture to the attachment point \"gl.COLOR_ATTACHMENT0\". a frame buffer in webgl has three\n     attachment points: COLOR_ATTACHMENT0, DEPTH_ATTACHMENT, and STENCIL_ATTACHMENT. You sort of know which attachment is for what by reading\n     their names.\n\n     The last argument is mipmapping level, I am not using mipmapping so its 0 (base level)\n     */\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    //bind the render buffer to attachment point \"gl.DEPTH_ATTACHMENT\"\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\n\n    //check if everything is ok with this frame buffer.\n    var shadowFrameBufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (gl.FRAMEBUFFER_COMPLETE !== shadowFrameBufferStatus)\n        console.log(\"shadow frame buffer is incomplete: \" + shadowFrameBufferStatus.toString());\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n}\nsetupShadowMapFrameBuffer();\n\n//-------------------------------------------------------------------------------------------------------------\n//  configure background texture\n//-------------------------------------------------------------------------------------------------------------\nfunction setupBackgroundTexture(image1, image2){\n    var bgTexture1 = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE1);\n    configureBgTexture(bgTexture1, image1);\n\n    var bgTexture2 = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE2);\n    configureBgTexture(bgTexture2, image2);\n\n    function configureBgTexture(texture, image){\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  render shadow map\n//-------------------------------------------------------------------------------------------------------------\nfunction renderShadowMapf() {\n    //switch to shadow shaders\n    gl.useProgram(shadowProgram);\n    //the second argument is transpose, which is always false in webgl\n    gl.uniformMatrix4fv(s_uObjMVP, false, shadowMVPMatrix);\n\n    // draw the mysterious object\n    // upload vertex buffer to shadow vertex shader\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_vertexBuffer);\n    //the arguments for gl.vertexAttribPointer are: uint index, int size, enum type, bool normalized, long stride, and long offset\n    gl.vertexAttribPointer(s_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(s_aVertexPosition);\n\n    //bind element buffer, draw shadow (store depth information in texture)\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m_elementBuffer);\n    //gl.UNSIGNED_SHORT corresponds to Uint16Array\n    gl.drawElements(gl.TRIANGLES, m_indices_number, gl.UNSIGNED_SHORT, 0);\n\n    // draw the wall\n    gl.uniformMatrix4fv(s_uObjMVP, false, wallShadowMVPMatrix);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, w_vertexBuffer);\n    gl.vertexAttribPointer(s_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, w_elementBuffer);\n    gl.drawElements(gl.TRIANGLES, w_indices_number, gl.UNSIGNED_SHORT, 0);\n}\n\nfunction renderShadowMapr(){\n    //switch to shadow shaders\n    gl.useProgram(shadowProgram);\n    //the second argument is transpose, which is always false in webgl\n    gl.uniformMatrix4fv(s_uObjMVP, false, shadowMVPMatrix);\n\n    // draw the mysterious object\n    // upload vertex buffer to shadow vertex shader\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_vertexBuffer);\n    //the arguments for gl.vertexAttribPointer are: uint index, int size, enum type, bool normalized, long stride, and long offset\n    gl.vertexAttribPointer(s_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\n    //bind element buffer, draw shadow (store depth information in texture)\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m_elementBuffer);\n    //gl.UNSIGNED_SHORT corresponds to Uint16Array\n    gl.drawElements(gl.TRIANGLES, m_indices_number, gl.UNSIGNED_SHORT, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, w_vertexBuffer);\n    gl.vertexAttribPointer(s_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, w_elementBuffer);\n    gl.drawElements(gl.TRIANGLES, w_indices_number, gl.UNSIGNED_SHORT, 0);\n}\n\n\n//-------------------------------------------------------------------------------------------------------------\n//  background rendering\n//-------------------------------------------------------------------------------------------------------------\nfunction renderBackgroundf(){\n    gl.useProgram(backgroundProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, b_vtBuffer);\n    gl.vertexAttribPointer(b_aVertexPosition, 2, gl.FLOAT, false, b_vtSize * 4, 0);\n    gl.enableVertexAttribArray(b_aVertexPosition);\n    gl.vertexAttribPointer(b_vTextureCoordinate, 2, gl.FLOAT, false, b_vtSize * 4, b_vtSize * 2);\n    gl.enableVertexAttribArray(b_vTextureCoordinate);\n    gl.uniform1i(b_uBgTexture1, 1);\n    gl.uniform1i(b_uBgTexture2, 2);\n    gl.uniform1f(b_radio, 0.0);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, b_vertices_number);\n}\n\nfunction renderBackgroundr(radio){\n    gl.useProgram(backgroundProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, b_vtBuffer);\n    gl.vertexAttribPointer(b_aVertexPosition, 2, gl.FLOAT, false, b_vtSize * 4, 0);\n    gl.vertexAttribPointer(b_vTextureCoordinate, 2, gl.FLOAT, false, b_vtSize * 4, b_vtSize * 2);\n    gl.uniform1f(b_radio, radio);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, b_vertices_number);\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  normal rendering\n//-------------------------------------------------------------------------------------------------------------\nfunction renderMysteriousObjectf(){\n    //switch to shaders used for normal rendering\n    gl.useProgram(normalProgram);\n\n    gl.uniform3fv(n_baseColorAmbient, objBaseColor_ambient);\n    gl.uniform3fv(n_baseColorDiffuse, objBaseColor_diffuse);\n    gl.uniform3fv(n_baseColorSpecular, objBaseColor_specular);\n    gl.uniform3fv(n_warmLightDir, warmLightDir);\n    gl.uniform3fv(n_warmLightColor, warmLightColor);\n    gl.uniform3fv(n_coldLightDir, coldLightDir);\n    gl.uniform3fv(n_coldLightColor, coldLightColor);\n    gl.uniform3fv(n_ambientLightColor, ambientLightColor);\n\n    gl.uniform1f(n_shininess, 8.0);\n    gl.uniform3fv(n_eyeCd, eyeCoord);\n\n    //upload shadow mvp matrix\n    gl.uniformMatrix4fv(n_uShadowMVP, false, shadowMVPMatrix);\n    //upload shadow map\n    //link the texture2D of gl.TEXTURE0 (by specifying 0 as the second argument) to n_uShadowMap\n    gl.uniform1i(n_uShadowMap, 0);\n    gl.uniform1fv(n_pcfOffsets, pcfOffsets);\n\n\n    gl.uniformMatrix4fv(n_uObjMPV, false, MVPMatrix);\n    gl.uniformMatrix3fv(n_uNormalM, false, normalMatrix);\n\n    // draw the mysterious object\n    // upload vertex buffer\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_vertexBuffer);\n    gl.vertexAttribPointer(n_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n    //will need to manually enable a attribute array\n    gl.enableVertexAttribArray(n_aVertexPosition);\n\n    //upload normal buffer\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_normalsBuffer);\n    gl.vertexAttribPointer(n_aNormal, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(n_aNormal);\n\n    //bind the element buffer and draw\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m_elementBuffer);\n    gl.drawElements(gl.TRIANGLES, m_indices_number, gl.UNSIGNED_SHORT, 0);\n}\n\nfunction renderMysteriousObjectr(){\n    gl.useProgram(normalProgram);\n\n    gl.uniformMatrix4fv(n_uShadowMVP, false, shadowMVPMatrix);\n    gl.uniformMatrix4fv(n_uObjMPV, false, MVPMatrix);\n\n    gl.uniformMatrix3fv(n_uNormalM, false, normalMatrix);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_vertexBuffer);\n    gl.vertexAttribPointer(n_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, m_normalsBuffer);\n    gl.vertexAttribPointer(n_aNormal, 3, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m_elementBuffer);\n    gl.drawElements(gl.TRIANGLES, m_indices_number, gl.UNSIGNED_SHORT, 0);\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  wall rendering\n//-------------------------------------------------------------------------------------------------------------\nfunction renderWallf(){\n    gl.useProgram(wallProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, w_vertexBuffer);\n\n    gl.vertexAttribPointer(w_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(w_aVertexPosition);\n\n    gl.uniformMatrix4fv(w_uObjMVP, false, wallMVPMatrix);\n    gl.uniformMatrix4fv(w_uShadowMVP, false, wallShadowMVPMatrix);\n\n    gl.uniform1i(w_uShadowMap, 0);\n    gl.uniform1fv(w_pcfOffsets, pcfOffsets);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, w_elementBuffer);\n    gl.drawElements(gl.TRIANGLES, w_indices_number, gl.UNSIGNED_SHORT, 0);\n}\n\nfunction renderWallr(){\n    gl.useProgram(wallProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, w_vertexBuffer);\n\n    gl.vertexAttribPointer(w_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, w_elementBuffer);\n    gl.drawElements(gl.TRIANGLES, w_indices_number, gl.UNSIGNED_SHORT, 0);\n}\n\nfunction initStats(){\n    var stats = new Stats();\n    stats.setMode(0);\n    stats.domElement.style.position = 'absolute';\n    stats.domElement.style.left = '0px';\n    stats.domElement.style.top = '0px';\n    $(\"#Stats-output\").append(stats.domElement);\n    return stats;\n}\n\n// var stats = initStats();\n\n//axis and matrices for static rotation\nvar staticRotateAxisInWorldSpace = vec3.create();\nvec3.subtract(staticRotateAxisInWorldSpace, shadowEyeCoord, shadowEyeLookAt);\n\nvar m_modelMatrixInverse = mat4.create();\nvar staticRotateAxisInModelSpace = vec3.create();\n\n//pointers used to tell whether player has passed the current level\n// var expectedPointerOneColor = vec4.fromValues(0, 1, 0, 1);\n// var expectedPointerTwoColor = vec4.fromValues(1, 1, 0, 1);\n// var currentPointerOneColor = vec4.fromValues(1, 0, 0, 1);\n// var currentPointerTwoColor = vec4.fromValues(0, 1, 1, 1);\n// var epMVPMatrix = mat4.create(); //mvp matrix for expected pointer\n// mat4.multiply(epMVPMatrix, VPMatrix, mat4.create());\n//\n// var originalPointerDirOne = vec3.fromValues(0, 1, 0);\n// var originalPointerDirTwo = vec3.fromValues(1, 0, 0);\n// var currentPointerDirOne = vec3.create();\n// var currentPointerDirTwo = vec3.create();\n// var expectedPointerDirOne = vec3.create();\n// var expectedPointerDirTwo = vec3.create();\n// vec3.copy(expectedPointerDirOne, originalPointerDirOne);\n// vec3.copy(expectedPointerDirTwo, originalPointerDirTwo);\n\nfunction updateUniformsf(){\n    //calculate mvp matrix\n    mat4.multiply(MVPMatrix, VPMatrix, m_modelMatrix);\n\n    //calculate normal matrix\n    mat3.normalFromMat4(normalMatrix, m_modelMatrix);\n\n    //calculate the shadow mvp matrix and upload it\n    mat4.multiply(shadowMVPMatrix, shadowVPMatrix, m_modelMatrix);\n}\n\nvar bgTransition = new _time__WEBPACK_IMPORTED_MODULE_0__[\"Transition\"](1000, 0.0, 0.0, 0.317, 1.256, 1.23, 1.332, 3.0, 0.0);\nvar bgRadio = 0.0;\nfunction updateUniformsr(){\n    if(deltaVerticalAngle !== 0 || deltaHorizontalAngle !==0) {\n        if(!isStaticRotation) {\n            mat4.rotateX(m_modelMatrix, m_modelMatrix, deltaVerticalAngle);\n            mat4.rotateY(m_modelMatrix, m_modelMatrix, deltaHorizontalAngle);\n        } else {\n            mat4.invert(m_modelMatrixInverse, m_modelMatrix);\n            vec3.transformMat4(staticRotateAxisInModelSpace, staticRotateAxisInWorldSpace, m_modelMatrixInverse);\n            mat4.rotate(m_modelMatrix, m_modelMatrix, deltaVerticalAngle, staticRotateAxisInModelSpace);\n        }\n\n        //calculate mvp matrix\n        mat4.multiply(MVPMatrix, VPMatrix, m_modelMatrix);\n\n        //calculate normal matrix\n        mat3.normalFromMat4(normalMatrix, m_modelMatrix);\n\n        //calculate the shadow mvp matrix and upload it\n        mat4.multiply(shadowMVPMatrix, shadowVPMatrix, m_modelMatrix);\n    }\n\n    if(bgTransition.isRunning){\n        bgRadio = bgTransition.getValue(false, true).y;\n    }\n}\n\nvar deltaVerticalAngle = 0, deltaHorizontalAngle = 0; //delta angle x, delta angle y\nvar mouseStartX = 0, mouseStartY = 0;\nvar mouseX = 0, mouseY = 0;\nvar maxAngelPerDrag = Math.PI * 2;\n\nvar mouseControl = (function (){\n\n    var dragging = false;\n\n    function mouseMoveEventHandler(event){\n        if(dragging) {\n            mouseX = event.clientX;\n            mouseY = event.clientY;\n        }\n    }\n\n    function mouseDownEventHandler(event){\n        dragging = true;\n\n        mouseStartX = event.clientX;\n        mouseStartY = event.clientY;\n        mouseX = event.clientX;\n        mouseY = event.clientY;\n    }\n\n    function mouseUpEventHandler() {\n        dragging = false;\n    }\n\n    function enableControl(){\n        dragging = false;\n        gui.addEventListener(\"mousemove\", mouseMoveEventHandler);\n        gui.addEventListener(\"mousedown\", mouseDownEventHandler);\n        window.addEventListener(\"mouseup\", mouseUpEventHandler);\n    }\n\n    function disableControl(){\n        gui.removeEventListener(\"mousemove\", mouseMoveEventHandler);\n        gui.removeEventListener(\"mousedown\", mouseDownEventHandler);\n        window.removeEventListener(\"mouseup\", mouseUpEventHandler);\n    }\n\n    return {\n        enableControl: enableControl,\n        disableControl: disableControl\n    };\n})();\n\nvar isStaticRotation = false;\n\nvar keyControl = (function(){\n\n    function getKey(evt){\n        evt = evt || window.event;\n        var charCode = evt.which || evt.keyCode;\n        return String.fromCharCode(charCode);\n    }\n\n    function keyPressEventHandler(evt){\n        if (getKey(evt) == \"s\") {\n            isStaticRotation = !isStaticRotation;\n        }\n    }\n\n    function enableControl(){\n        document.addEventListener(\"keypress\", keyPressEventHandler);\n    }\n\n    function disableControl(){\n        document.removeEventListener(\"keypress\", keyPressEventHandler);\n    }\n\n    return {\n        enableControl: enableControl,\n        disableControl: disableControl\n    }\n\n})();\n\nconst resumePlaying = (function(){\n    var isFirstTime = true;\n\n    function p(){\n        isStaticRotation = false;\n        mouseControl.enableControl();\n        keyControl.enableControl();\n\n        if(isFirstTime) {\n            isFirstTime = false;\n            drawf();\n        } else {\n            drawr();\n        }\n    }\n\n    return p;\n})();\n\nfunction stopPlaying(){\n    mouseControl.disableControl();\n    keyControl.disableControl();\n}\n\nfunction drawBackground(){\n    gl.disable(gl.DEPTH_TEST);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.viewport(0, 0, viewportWidth, viewportHeight);\n    renderBackgroundf();\n\n    gl.enable(gl.DEPTH_TEST);\n}\n\nfunction drawf(){\n    updateUniformsf();\n\n    drawBackground();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFrameBuffer);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.viewport(0, 0, shadowViewPortWidth, shadowViewPortHeight);\n    renderShadowMapf();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, viewportWidth, viewportHeight);\n    renderMysteriousObjectf();\n\n    // renderPointerf();\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    renderWallf();\n\n    gl.disable(gl.BLEND);\n\n    drawr();\n}\n\nfunction drawr(){\n    requestAnimationFrame(drawr);\n\n    deltaVerticalAngle = ((mouseY - mouseStartY) / viewportHeight) * maxAngelPerDrag;\n    deltaHorizontalAngle = ((mouseX - mouseStartX) / viewportWidth) * maxAngelPerDrag;\n\n    mouseStartX = mouseX;\n    mouseStartY = mouseY;\n\n    updateUniformsr();\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.viewport(0, 0, viewportWidth, viewportHeight);\n    renderBackgroundr(bgRadio);\n\n    gl.enable(gl.DEPTH_TEST);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFrameBuffer);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.viewport(0, 0, shadowViewPortWidth, shadowViewPortHeight);\n    renderShadowMapr();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, viewportWidth, viewportHeight);\n    renderMysteriousObjectr();\n\n    // renderPointerr();\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    renderWallr();\n\n    gl.disable(gl.BLEND);\n}\n\nvar startDrawingIfPrepared = (function(){\n    var count = 6;\n    return function(){\n        --count;\n        if(count === 0) {\n            drawBackground();\n        }\n    }\n})();\n\nfunction init(){\n    //common settings\n    //there is no need to draw back faces\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    gl.clearColor(1.0, 1.0, 1.0, 1.0);\n\n    //do remember to update the count in `startDrawingIfPrepared` if the following lines are modified.\n    loadShadersAndCreateProgram(\"src/shaders/mysObjVertex.glsl\", \"src/shaders/mysObjFrag.glsl\", createNormalProgram, startDrawingIfPrepared);\n    loadShadersAndCreateProgram(\"src/shaders/shadowVertex.glsl\", \"src/shaders/shadowFrag.glsl\", createShadowProgram, startDrawingIfPrepared);\n    loadShadersAndCreateProgram(\"src/shaders/wallVertex.glsl\", \"src/shaders/wallFrag.glsl\", createWallProgram, startDrawingIfPrepared);\n    loadShadersAndCreateProgram(\"src/shaders/bgVertex.glsl\", \"src/shaders/bgFrag.glsl\", createBackgroundProgram, startDrawingIfPrepared);\n    // loadShadersAndCreateProgram(\"shaders/lineVertex.glsl\", \"shaders/lineFrag.glsl\", createLineProgram, startDrawingIfPrepared);\n    loadBackgroundImage(startDrawingIfPrepared);\n    loadSceneModelData(startDrawingIfPrepared);\n}\n\nfunction loadShadersAndCreateProgram(vertexShaderPath, fragmentShaderPath, createProgramCallback, doneCallback) {\n    var vertexShader, fragmentShader;\n    $.get(vertexShaderPath, function(s){\n        vertexShader = s;\n        if(vertexShader && fragmentShader) {\n            createProgramCallback(vertexShader, fragmentShader);\n            doneCallback();\n        }\n    });\n\n    $.get(fragmentShaderPath, function(s){\n        fragmentShader = s;\n        if(vertexShader && fragmentShader) {\n            createProgramCallback(vertexShader, fragmentShader);\n            doneCallback();\n        }\n    });\n}\n\nfunction loadBackgroundImage(doneCallback){\n    var img1 = false, img2 = false;\n    var bgImg1 = new Image();\n    var bgImg2 = new Image();\n\n    bgImg1.onload = function(){\n        img1 = true;\n        tryStart();\n    };\n\n    bgImg2.onload = function(){\n        img2 = true;\n        tryStart();\n    };\n\n    function tryStart(){\n        if(img1 && img2){\n            setupBackgroundTexture(bgImg1, bgImg2);\n            doneCallback();\n        }\n    }\n\n    bgImg1.src=\"materials/bg.png\";\n    bgImg2.src=\"materials/bg2.png\";\n}\n\nfunction loadSceneModelData(doneCallback){\n    $.get(\"models/scene/scene.obj\", function(dataStr) {\n        setupSceneBuffers(dataStr);\n        doneCallback();\n    });\n}\n\n//-------------------------------------------------------------------------------------------------------------\n//  debug\n//-------------------------------------------------------------------------------------------------------------\n// var lineOneBuffer = gl.createBuffer();\n// var lineOneVertices = new Float32Array([0, 0, 0, 0, 30.0, 0]);\n// gl.bindBuffer(gl.ARRAY_BUFFER, lineOneBuffer);\n// gl.bufferData(gl.ARRAY_BUFFER, lineOneVertices, gl.STATIC_DRAW);\n//\n// var lineTwoBuffer = gl.createBuffer();\n// var lineTwoVertices = new Float32Array([0, 0, 0, 30.0, 0, 0]);\n// gl.bindBuffer(gl.ARRAY_BUFFER, lineTwoBuffer);\n// gl.bufferData(gl.ARRAY_BUFFER, lineTwoVertices, gl.STATIC_DRAW);\n//\n// var lineProgram;\n// var l_aVertexPosition, l_uObjMVP, l_color;\n// function createLineProgram(vertexShaderSrc, fragmentShaderSrc){\n//     lineProgram = createProgram(\"#line-vertex\", \"#line-frag\", vertexShaderSrc, fragmentShaderSrc);\n//     l_aVertexPosition = gl.getAttribLocation(lineProgram, \"aVertexPosition\");\n//     l_uObjMVP = gl.getUniformLocation(lineProgram, \"uObjMVP\");\n//     l_color = gl.getUniformLocation(lineProgram, \"lineColor\");\n// }\n\n// function renderPointerf(){\n//     console.log(lineProgram);\n//     gl.lineWidth(4);\n//\n//     gl.useProgram(lineProgram);\n//     gl.enableVertexAttribArray(l_aVertexPosition);\n//\n//     gl.uniformMatrix4fv(l_uObjMVP, false, epMVPMatrix);\n//\n//     gl.bindBuffer(gl.ARRAY_BUFFER, lineOneBuffer);\n//     gl.vertexAttribPointer(l_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n//\n//     gl.uniform4fv(l_color, expectedPointerOneColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n//     gl.uniform4fv(l_color, currentPointerOneColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n//\n//\n//     gl.bindBuffer(gl.ARRAY_BUFFER, lineTwoBuffer);\n//     gl.vertexAttribPointer(l_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n//\n//     gl.uniform4fv(l_color, expectedPointerTwoColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n//     gl.uniform4fv(l_color, currentPointerTwoColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n// }\n//\n// function renderPointerr(){\n//     gl.useProgram(lineProgram);\n//     gl.bindBuffer(gl.ARRAY_BUFFER, lineOneBuffer);\n//\n//     gl.vertexAttribPointer(l_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n//\n//     gl.bindBuffer(gl.ARRAY_BUFFER, lineOneBuffer);\n//     gl.vertexAttribPointer(l_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n//\n//     gl.uniformMatrix4fv(l_uObjMVP, false, MVPMatrix);\n//     gl.uniform4fv(l_color, currentPointerOneColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n//\n//     gl.uniformMatrix4fv(l_uObjMVP, false, epMVPMatrix);\n//     gl.uniform4fv(l_color, expectedPointerTwoColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n//\n//     gl.bindBuffer(gl.ARRAY_BUFFER, lineTwoBuffer);\n//     gl.vertexAttribPointer(l_aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n//\n//     gl.uniformMatrix4fv(l_uObjMVP, false, MVPMatrix);\n//     gl.uniform4fv(l_color, currentPointerTwoColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n//\n//     gl.uniformMatrix4fv(l_uObjMVP, false, epMVPMatrix);\n//     gl.uniform4fv(l_color, expectedPointerOneColor);\n//     gl.drawArrays(gl.LINES, 0, 2);\n// }\n\ninit();\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/menu.js":
/*!*********************!*\
  !*** ./src/menu.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ \"./src/main.js\");\n\n\nvar gui = $(\"#gui\");\nvar menuButton = $(\"#menu-open-button\");\nvar main = $(\"#main\");\nvar backToGameButton = $(\"#back-to-game-button\");\nvar loadModelButton = $(\"#load-button\");\nvar quickDemoButton = $(\"#quick-demo\");\nvar aboutButton = $(\"#about-button\");\nvar about = $(\"#about\");\nvar backFromAboutButton = $(\"#back-from-about-button\");\nvar hiddenUploadButton = $(\"#input\");\n\n//showMainMenu();\n\nfunction darkenGui(complete){\n    if(!complete){\n        gui.css(\"background-color\", \"rgba(0, 0, 0, 0.3\");\n    } else {\n        gui.css(\"background-color\", \"rgba(0, 0, 0, 0.9\");\n    }\n}\n\nfunction lightenGui(){\n    gui.css(\"background-color\", \"rgba(0, 0, 0, 0.0\");\n}\n\nfunction showMainMenu(){\n    darkenGui();\n    menuButton.hide();\n    main.show();\n}\n\nfunction hideMainMenu(inTransition/*if true, that means we are loading model data. So for now simply hide all buttons, when the model data is ready, lightenGui will then be called to lighten the background*/){\n    if(!inTransition)\n        lightenGui();\n    menuButton.show();\n    main.hide();\n}\n\nfunction modelReady(modelStr){\n    lightenGui();\n    Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"setupMysteriousObjectBuffer\"])(modelStr);\n    Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"randomizeRotation\"])();\n    Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"updateUniformsf\"])();\n    Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"resumePlaying\"])();\n}\n\nmenuButton.click(function(){\n    Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"stopPlaying\"])();\n    showMainMenu();\n});\n\nbackToGameButton.click(function(){\n    Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"resumePlaying\"])();\n    hideMainMenu();\n});\n\nloadModelButton.click(function(){\n    hiddenUploadButton.click();\n});\n\nhiddenUploadButton.change(function(){\n    var file = this.files[0];\n    if(file) {\n        hideMainMenu(true);\n        backToGameButton.show(); //this button is not shown by default, it is only shown when you successfully load a model for at least once\n        var r = new FileReader();\n        r.onload = function() {\n            var contents = r.result;\n            modelReady(contents);\n        };\n        r.readAsText(file);\n    }\n});\n\nquickDemoButton.click(function(){\n    hideMainMenu(true);\n    backToGameButton.show();\n    $.get(\"models/levels/1.obj\", function(s){\n        modelReady(s);\n    });\n});\n\naboutButton.click(function(){\n    main.hide();\n    about.show();\n});\n\nbackFromAboutButton.click(function(){\n    about.hide();\n    main.show();\n});\n\n\n//# sourceURL=webpack:///./src/menu.js?");

/***/ }),

/***/ "./src/obj.js":
/*!********************!*\
  !*** ./src/obj.js ***!
  \********************/
/*! exports provided: OBJDoc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OBJDoc\", function() { return OBJDoc; });\n/**\r\n * Constructor\r\n * it assumes that the vertices using 3DS Max default coordinate system. When exporting to obj file, \"flipYZ axis\" option is not\r\n * selected.\r\n * @constructor\r\n */\r\nfunction OBJDoc() {\r\n    this.objects = new Array(0);   // Initialize the property for Object\r\n    this.vertices = new Array(0);  // Initialize the property for Vertex\r\n    this.normals = new Array(0);   // Initialize the property for Normal\r\n}\r\n\r\n// Parsing the OBJ file\r\nOBJDoc.prototype.parse = function(fileString, scale) {\r\n    var lines = fileString.split('\\n');  // Break up into lines and store them as array\r\n    lines.push(null); // Append null. So that if I find null I will know that I have reached the end..\r\n    var index = 0;    // Initialize index of line.\r\n\r\n    //define the default values here.\r\n    scale = scale || 1;\r\n    var currentObject = null;\r\n\r\n    // Parse line by line\r\n    var line;         // A string in the line to be parsed\r\n    var sp = new StringParser();  // Create StringParser\r\n    while ((line = lines[index++]) != null) {\r\n        sp.init(line);                  // init StringParser\r\n        var command = sp.getWord();     // Get command\r\n        if (command === null)\r\n            continue;  // check null command, or more precisely, a line that has no words....\r\n\r\n        switch (command) {\r\n            case '#':\r\n                continue;  // Skip comments\r\n            case 'o':\r\n            case 'g':   // Read Object name\r\n                //create a object, and set its name...an object is basically a collection of faces. \r\n                //and of course methods to add faces.\r\n                var object = this.parseObjectName(sp);\r\n                this.objects.push(object);\r\n                currentObject = object;\r\n                continue; // Go to the next line\r\n            case 'v':   // Read vertex\r\n                var vertex = this.parseVertex(sp, scale);\r\n                this.vertices.push(vertex);\r\n                continue; // Go to the next line\r\n            case 'vn':   // Read normal\r\n                var normal = this.parseNormal(sp);\r\n                this.normals.push(normal);\r\n                continue; // Go to the next line\r\n            case 'f': // Read face\r\n                var face = this.parseFace(sp);\r\n                currentObject.addFace(face); //it not only adds the face to the object but also updates the object's 'numberIndices'\r\n                continue; // Go to the next line\r\n            case 'usemtl': // Read Material name\r\n                continue; // Go to the next line\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nOBJDoc.prototype.parseObjectName = function(sp) {\r\n    var name = sp.getWord();\r\n    return (new OBJObject(name));\r\n};\r\n\r\nOBJDoc.prototype.parseVertex = function(sp, scale) {\r\n    var x = sp.getFloat() * scale; //getFloat: get a word and parse it to a float...\r\n    var z = 0 - sp.getFloat() * scale; //in 3ds max y axis is equivalent to the opposite of z axis in opengl.\r\n    var y = sp.getFloat() * scale; // in 3ds max z axis is equivalent to y axis in opengl\r\n    return (new Vertex(x, y, z));\r\n};\r\n\r\nOBJDoc.prototype.parseNormal = function(sp) {\r\n    var x = sp.getFloat();\r\n    var z = 0 - sp.getFloat();\r\n    var y = sp.getFloat();\r\n    return (new Normal(x, y, z));\r\n};\r\n\r\nOBJDoc.prototype.parseFace = function(sp) {\r\n    var face = new Face();\r\n    // get indices\r\n    while(true) {\r\n        var word = sp.getWord();\r\n        if (word === null)\r\n            break;\r\n        var subWords = word.split('/');\r\n\r\n        var vi = parseInt(subWords[0]) - 1;\r\n        face.vIndices.push(vi);\r\n\r\n        var ni = parseInt(subWords[2]) - 1;\r\n        face.nIndices.push(ni);\r\n    }\r\n\r\n    face.numIndices = face.vIndices.length;\r\n    return face;\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Retrieve the information for drawing 3D model\r\n//------------------------------------------------------------------------------\r\nOBJDoc.prototype.getDrawingInfo = function() {\r\n    // Create an arrays for vertex coordinates, normals, colors, and indices\r\n\r\n\r\n    var r = {};\r\n\r\n    // Set vertex, normal and color\r\n    for (var i = 0; i < this.objects.length; i++) {\r\n        var w = 0;\r\n        var object = this.objects[i];\r\n\r\n        var numIndices = object.numIndices;\r\n        var numVertices = numIndices;\r\n        var vertices = new Float32Array(numVertices * 3);\r\n        var normals = new Float32Array(numVertices * 3);\r\n        var indices = new Uint16Array(numIndices);\r\n\r\n        for (var j = 0; j < object.faces.length; j++) {\r\n            var face = object.faces[j];\r\n            for (var k = 0; k < face.vIndices.length; k++) {\r\n                // Set index\r\n                indices[w] = w;\r\n                // Copy vertex\r\n                var vIdx = face.vIndices[k];\r\n                var vertex = this.vertices[vIdx];\r\n                vertices[w * 3] = vertex.x;\r\n                vertices[w * 3 + 1] = vertex.y;\r\n                vertices[w * 3 + 2] = vertex.z;\r\n                // Copy normal\r\n                var nIdx = face.nIndices[k];\r\n                var normal = this.normals[nIdx];\r\n                normals[w * 3] = normal.x;\r\n                normals[w * 3 + 1] = normal.y;\r\n                normals[w * 3 + 2] = normal.z;\r\n\r\n                w++;\r\n            }\r\n        }\r\n        console.log(object.name);\r\n        r[object.name] = new DrawingInfo(vertices, normals, indices);\r\n\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Vertex Object\r\n//------------------------------------------------------------------------------\r\nvar Vertex = function(x, y, z) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Normal Object\r\n//------------------------------------------------------------------------------\r\nvar Normal = function(x, y, z) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// OBJObject Object\r\n//------------------------------------------------------------------------------\r\nvar OBJObject = function(name) {\r\n    this.name = name;\r\n    this.faces = new Array(0);\r\n    this.numIndices = 0;\r\n};\r\n\r\nOBJObject.prototype.addFace = function(face) {\r\n    this.faces.push(face);\r\n    this.numIndices += face.numIndices;\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Face Object\r\n//------------------------------------------------------------------------------\r\nvar Face = function() {\r\n    this.vIndices = new Array(0);\r\n    this.nIndices = new Array(0);\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// DrawInfo Object\r\n//------------------------------------------------------------------------------\r\nvar DrawingInfo = function(vertices, normals, indices) {\r\n    this.vertices = vertices;\r\n    this.normals = normals;\r\n    this.indices = indices;\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Constructor\r\n//------------------------------------------------------------------------------\r\nvar StringParser = function(str) {\r\n    this.str;   // Store the string specified by the argument\r\n    this.index; // Position in the string to be processed\r\n    this.init(str);\r\n};\r\n// Initialize StringParser object\r\nStringParser.prototype.init = function(str) {\r\n    this.str = str;\r\n    this.index = 0;\r\n};\r\n\r\n/**\r\n * Skip delimiters\r\n * @returns the index (in the line, or in the string) of the next none delimiter letter.\r\n */\r\nStringParser.prototype.skipDelimiters = function() {\r\n    for (var i = this.index, len = this.str.length; i < len; i++) {\r\n        var c = this.str.charAt(i);\r\n        // Skip TAB, Space, '(', ')\r\n        if (c == '\\t' || c == ' ' || c == '(' || c == ')' || c == '\"')\r\n            continue;\r\n        break;\r\n    }\r\n    this.index = i;\r\n};\r\n\r\n// Skip to the next word\r\nStringParser.prototype.skipToNextWord = function() {\r\n    this.skipDelimiters();\r\n    var n = getWordLength(this.str, this.index);\r\n    this.index += (n + 1);\r\n};\r\n\r\n// Get word\r\nStringParser.prototype.getWord = function() {\r\n    this.skipDelimiters();\r\n    var n = getWordLength(this.str, this.index);\r\n    if (n === 0)\r\n        return null; //return null if there is no more word after skipping delimiters....\r\n    //Trimming is needed cos I found some weird symbol that is either tab, white space or anything else\r\n    //appended at the end of a line in some cases.\r\n    //To be more precisely, this weird symbol is appended at each line of \"indices\".\r\n    //The lucky thing is that the symbol can be removed by trim().\r\n    var word = this.str.substr(this.index, n).trim();\r\n    //we need to increment the index anyway so that next time getword() is called, it starts with the correct index.\r\n    this.index += (n + 1);\r\n    \r\n    if(word === \"\"){\r\n        //if the weird symbol is trimmed, then the word would equals to an empty string.\r\n        //in this case it is effectively the same as \"there is no word\", and therefore the method should return null.\r\n        return null;\r\n    }\r\n    \r\n    return word;\r\n};\r\n\r\n// Get integer\r\nStringParser.prototype.getInt = function() {\r\n    return parseInt(this.getWord());\r\n};\r\n\r\n// Get floating number\r\nStringParser.prototype.getFloat = function() {\r\n    return parseFloat(this.getWord());\r\n};\r\n\r\n// Get the length of word\r\nfunction getWordLength(str, start) {\r\n    var n = 0;\r\n    for (var i = start, len = str.length; i < len; i++) {\r\n        var c = str.charAt(i);\r\n        if (c === '\\t' || c === ' ' || c === '(' || c === ')' || c === '\"')\r\n            break;\r\n    }\r\n    return i - start;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/obj.js?");

/***/ }),

/***/ "./src/time.js":
/*!*********************!*\
  !*** ./src/time.js ***!
  \*********************/
/*! exports provided: ElapsedTime, Transition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElapsedTime\", function() { return ElapsedTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Transition\", function() { return Transition; });\nfunction ElapsedTime(){\n    this.startTime = +new Date();\n}\n\nElapsedTime.prototype.getElapsedTime = function(){\n    return +new Date() - this.startTime;\n};\n\nfunction Transition(duration, startX, startY, contr1X, contr1Y, contr2X, contr2Y, endX, endY){\n    this.duration = duration;\n    this.startX = startX;\n    this.startY = startY;\n    this.contr1X = contr1X;\n    this.contr1Y = contr1Y;\n    this.contr2X = contr2X;\n    this.contr2Y = contr2Y;\n    this.endX = endX;\n    this.endY = endY;\n    this.isRunning = false;\n}\n\nTransition.prototype.begin = function(){\n    this.isRunning = true;\n    this.time = new ElapsedTime();\n};\n\nTransition.prototype.getValue = function(getX, getY){\n    if(!this.isRunning)\n        return -1;\n\n    var et = this.time.getElapsedTime();\n\n    if(et > this.duration){\n        this.isRunning = false;\n        return {x: this.endX, y: this.endY};\n    }\n\n    var t = et / this.duration;\n\n    var x, y;\n    if(getX)\n        x = this.calBezier(t, this.startX, this.contr1X, this.contr2X, this.endX);\n\n    if(getY)\n        y = this.calBezier(t, this.startY, this.contr1Y, this.contr2Y, this.endY);\n\n    return {\n        x: x,\n        y: y\n    };\n};\n\nTransition.prototype.calBezier = function calBezier(t, start, c1, c2, end){\n    return Math.pow(1-t, 3)*start\n        + 3*Math.pow(1-t, 2)*t*c1\n        + 3*(1-t)*Math.pow(t, 2)*c2\n        + Math.pow(t, 3)*end;\n};\n\n\n//# sourceURL=webpack:///./src/time.js?");

/***/ })

/******/ });